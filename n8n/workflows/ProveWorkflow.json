{
  "updatedAt": "2026-02-17T11:09:35.161Z",
  "createdAt": "2026-02-16T11:51:37.947Z",
  "id": "testLeanMultiAgent01",
  "name": "Test Lean",
  "description": null,
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {},
      "id": "manual-trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        0,
        -208
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"initialize\",\n  \"params\": {\n    \"protocolVersion\": \"2024-11-05\",\n    \"capabilities\": {},\n    \"clientInfo\": {\n      \"name\": \"n8n-test\",\n      \"version\": \"0.1.0\"\n    }\n  },\n  \"id\": 1\n}",
        "options": {}
      },
      "id": "neo4j-init",
      "name": "Neo4j MCP Init",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        272,
        -208
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"write-cypher\",\"arguments\":{\"query\":\"MATCH (n) DETACH DELETE n\"}},\"id\":2}",
        "options": {}
      },
      "id": "delete-all-nodes",
      "name": "Delete All Nodes",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        528,
        -208
      ]
    },
    {
      "parameters": {
        "jsCode": "const fs = require('fs');\nconst cypher = fs.readFileSync('/home/node/.n8n-files/script.txt', 'utf8').trim();\nconst body = JSON.stringify({jsonrpc:'2.0',method:'tools/call',params:{name:'write-cypher',arguments:{query:cypher}},id:3});\nreturn [{ json: { body: body } }];"
      },
      "id": "read-script",
      "name": "Read Script",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        784,
        -208
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {}
      },
      "id": "init-db",
      "name": "Initialize DB",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1040,
        -208
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://python-mcp:7010/lean/command",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"cmd\": \"import WorldModel.KB.Relations\"}",
        "options": {
          "timeout": 300000
        }
      },
      "id": "warm-up-lean",
      "name": "Warm Up Lean",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1296,
        -208
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "chat-trigger",
      "name": "Chat Trigger",
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        304
      ],
      "webhookId": "chat-trigger-webhook"
    },
    {
      "parameters": {
        "options": {
          "systemMessage": "You are a request classifier. Analyze the user's input and determine if it is:\n1. A \"query\" \u2014 asking for information about the database (counts, lists, lookups, etc.)\n2. A \"meeting\" \u2014 requesting to arrange or schedule a meeting for a patient\n\nRespond with ONLY a JSON object, no other text:\n{\"type\": \"query\", \"prompt\": \"<original user input>\"}\nor\n{\"type\": \"meeting\", \"prompt\": \"<original user input>\"}",
          "maxIterations": 3
        }
      },
      "id": "router-agent",
      "name": "Router Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        304,
        304
      ]
    },
    {
      "parameters": {
        "jsCode": "const raw = $input.first().json.output;\n// Strip markdown code fences if present\nconst text = raw.replace(/^```(?:json)?\\n?/gm, '').replace(/```$/gm, '').trim();\ntry {\n  const parsed = JSON.parse(text);\n  return [{ json: { type: parsed.type, prompt: parsed.prompt } }];\n} catch (e) {\n  // Fallback: if router output isn't valid JSON, treat as query\n  return [{ json: { type: \"query\", prompt: raw } }];\n}"
      },
      "id": "parse-route",
      "name": "Parse Route",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        560,
        304
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-meeting",
              "leftValue": "={{ $json.type }}",
              "rightValue": "meeting",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-meeting",
      "name": "IF Is Meeting",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        800,
        304
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.prompt }}",
        "options": {
          "systemMessage": "You are an automated scheduling agent. Your task is to arrange a meeting at a Clinic for a Patient with a Clinician. The Clinic must be in the same city the Patient lives in, the Clinician must be assigned to the Clinic, and they must have a language in common.\n\nUse get_neo4j_schema to inspect the database structure, then use read_cypher to find relevant data. Do not read the whole database \u2014 only what you need.\n\nIf there is no possible meeting, respond with ONLY: null\n\nIf a meeting is possible, respond with ONLY a JSON object (no other text):\n{\n  \"meeting\": {\"clinic\": \"<name>\", \"patient\": \"<name>\", \"clinician\": \"<name>\"},\n  \"facts\": [\n    {\"relation\": \"<predicate>\", \"source\": \"<entity>\", \"target\": \"<entity>\"},\n    ...\n  ],\n  \"explanation\": \"<why the facts support this meeting>\"\n}\n\nThe \"relation\" field must use the neo4j relationship names: hasRole, speaks, lives, assigned, isIn, etc.\nThe \"source\" and \"target\" must use the exact neo4j node labels (e.g., \"Jose\", \"ValClinic\", \"Spanish\", \"Valencia\", \"Clinician\", \"Patient\", etc.).\n\nDo not create the meeting in the database.",
          "maxIterations": 10
        }
      },
      "id": "meeting-agent",
      "name": "Meeting Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        1088,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "const text = $input.first().json.output;\ntry {\n  const trimmed = text.replace(/^```(?:json)?\\n?/gm, '').replace(/```$/gm, '').trim();\n  if (trimmed === 'null') {\n    return [{ json: { valid: false, meetingJson: null } }];\n  }\n  const match = trimmed.match(/\\{[\\s\\S]*\\}/);\n  if (match) {\n    const parsed = JSON.parse(match[0]);\n    const meetingJson = JSON.stringify(parsed);\n    const proofPrompt = 'Construct a Lean 4 proof of legalMeeting for this meeting specification:\\n' + meetingJson;\n    return [{ json: { valid: true, meetingJson, meetingData: parsed, proofPrompt } }];\n  }\n  return [{ json: { valid: false, meetingJson: null } }];\n} catch (e) {\n  return [{ json: { valid: false, meetingJson: null } }];\n}"
      },
      "id": "extract-json",
      "name": "Extract Meeting JSON",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1360,
        160
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-valid",
              "leftValue": "={{ $json.valid }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-valid",
      "name": "IF Meeting Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1600,
        160
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $input.first().json.proofPrompt }}",
        "options": {
          "systemMessage": "You are a Lean 4 proof agent. You receive a meeting specification in JSON and must construct a formal proof that the meeting is legal according to the WorldModel knowledge base.\n\n## WorldModel.KB.Types\n\nEntity types are inductive types parameterized by String:\n\n```lean\ninductive Language : String \u2192 Type where\n  | mk : (s : String) \u2192 Language s\n\ninductive City : String \u2192 Type where\n  | mk : (s : String) \u2192 City s\n\ninductive Clinic : String \u2192 Type where\n  | mk : (s : String) \u2192 Clinic s\n\ninductive Human : String \u2192 Type where\n  | mk : (s : String) \u2192 Human s\n\ninductive Role where\n  | Patient | Administrator | Clinician\n```\n\nTo construct an entity, use `.mk` with the string label, e.g. `Human.mk \"Jose\" : Human \"Jose\"`.\n\n## WorldModel.KB.Relations\n\nRelations are inductive types with a single `.mk` constructor. Derived concepts use `Nonempty` to bridge Type \u2192 Prop.\n\n```lean\ninductive hasRole {h : String} (a : Human h) (r : Role) : Type where\n  | mk : hasRole a r\n\ninductive speaks {h l : String} (a : Human h) (b : Language l) : Type where\n  | mk : speaks a b\n\ninductive lives {h c : String} (a : Human h) (b : City c) : Type where\n  | mk : lives a b\n\ninductive assigned {h c : String} (a : Human h) (b : Clinic c) : Type where\n  | mk : assigned a b\n\ninductive isIn {c t : String} (a : Clinic c) (b : City t) : Type where\n  | mk : isIn a b\n\ndef canCommunicate {h1 h2 : String} (p1 : Human h1) (p2 : Human h2) : Prop :=\n  \u2203 (l : String) (lang : Language l), Nonempty (speaks p1 lang) \u2227 Nonempty (speaks p2 lang)\n\ndef clinicianCanServe {h1 h2 : String} (clinician : Human h1) (patient : Human h2) : Prop :=\n  Nonempty (hasRole clinician .Clinician) \u2227 Nonempty (hasRole patient .Patient) \u2227\n  canCommunicate clinician patient\n\ndef clinicInPatientCity {c p : String} (clinic : Clinic c) (patient : Human p) : Prop :=\n  \u2203 (t : String) (city : City t), Nonempty (isIn clinic city) \u2227 Nonempty (lives patient city)\n\ndef legalMeeting {c p cl : String} (clinic : Clinic c) (patient : Human p) (clinician : Human cl) : Prop :=\n  clinicInPatientCity clinic patient \u2227 clinicianCanServe clinician patient \u2227\n  Nonempty (assigned clinician clinic)\n```\n\n## How to construct entities and proofs\n\nGiven JSON input like `{\"clinic\": \"ValClinic\", \"patient\": \"Jose\", \"clinician\": \"Allen\", ...}`:\n\n1. Construct entity objects using `.mk`:\n   ```lean\n   def clinic := Clinic.mk \"ValClinic\"\n   def patient := Human.mk \"Jose\"\n   def clinician := Human.mk \"Allen\"\n   ```\n\n2. Relation instances are also constructed with `.mk` \u2014 e.g. `speaks.mk : speaks (Human.mk \"Allen\") (Language.mk \"Spanish\")`. Since the relation type only has one constructor, `.mk` always works when the types align.\n\n3. Wrap in `Nonempty` using `\u27e8.mk\u27e9` for Prop-level statements.\n\n## Target: prove legalMeeting\n\nlegalMeeting requires three conjuncts:\n1. `clinicInPatientCity clinic patient` \u2014 \u2203 a city such that `Nonempty (isIn clinic city) \u2227 Nonempty (lives patient city)`\n2. `clinicianCanServe clinician patient` \u2014 `Nonempty (hasRole clinician .Clinician) \u2227 Nonempty (hasRole patient .Patient) \u2227 canCommunicate clinician patient`\n3. `Nonempty (assigned clinician clinic)`\n\nFor each `Nonempty` wrapper, the proof is `\u27e8.mk\u27e9`. For existentials, provide the string and the `.mk` witness.\n\n## Proof template\n\n```lean\nimport WorldModel.KB.Relations\n\ndef clinic := Clinic.mk \"<ClinicName>\"\ndef patient := Human.mk \"<PatientName>\"\ndef clinician := Human.mk \"<ClinicianName>\"\n\ntheorem meeting_legal : legalMeeting clinic patient clinician :=\n  \u27e8\u27e8\"<CityName>\", .mk \"<CityName>\", \u27e8.mk\u27e9, \u27e8.mk\u27e9\u27e9,\n   \u27e8\u27e8.mk\u27e9, \u27e8.mk\u27e9, \"<SharedLanguage>\", .mk \"<SharedLanguage>\", \u27e8.mk\u27e9, \u27e8.mk\u27e9\u27e9,\n   \u27e8.mk\u27e9\u27e9\n```\n\n## Example\n\nFor ValClinic, Jose, Allen (sharing Spanish, in Valencia):\n\n```lean\nimport WorldModel.KB.Relations\n\ndef clinic := Clinic.mk \"ValClinic\"\ndef patient := Human.mk \"Jose\"\ndef clinician := Human.mk \"Allen\"\n\ntheorem meeting_legal : legalMeeting clinic patient clinician :=\n  \u27e8\u27e8\"Valencia\", .mk \"Valencia\", \u27e8.mk\u27e9, \u27e8.mk\u27e9\u27e9,\n   \u27e8\u27e8.mk\u27e9, \u27e8.mk\u27e9, \"Spanish\", .mk \"Spanish\", \u27e8.mk\u27e9, \u27e8.mk\u27e9\u27e9,\n   \u27e8.mk\u27e9\u27e9\n```\n\n## Interpreting lean_command responses\n\nThe tool returns JSON with:\n- \"ok\": true means the code was accepted by Lean\n- \"messages\" with \"severity\": \"info\" are NORMAL informational output, NOT errors\n- \"messages\" with \"severity\": \"error\" are actual errors that need fixing\n- \"sorries\": [] (empty array) means no incomplete proofs \u2014 this is GOOD\n- An empty \"messages\" array or only \"info\" messages means SUCCESS\n\nA successful proof looks like: {\"ok\": true, \"result\": {\"messages\": [], \"sorries\": []}}\nThis means the proof compiled and is COMPLETE. Stop immediately and output the code.\n\n## Instructions\n\n1. Read the meeting JSON from the input\n2. Construct entity objects using `.mk` with the string labels from the JSON\n3. Construct the proof term following the template \u2014 every relation witness is `.mk`, every Nonempty wrapper is `\u27e8.mk\u27e9`\n4. Use the lean_command tool to verify: send the COMPLETE code (with `import WorldModel.KB.Relations`)\n5. If the response has \"ok\": true and no \"error\" severity messages, the proof is VERIFIED \u2014 stop and output the result\n6. If there are errors, fix and retry\n7. When the proof compiles, output ONLY the complete Lean4 code in a ```lean code block",
          "maxIterations": 10
        }
      },
      "id": "proof-agent",
      "name": "Proof Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        1888,
        32
      ]
    },
    {
      "parameters": {
        "jsCode": "const text = $input.first().json.output;\nconst meetingJson = $('Extract Meeting JSON').first().json.meetingJson;\n\n// Extract lean code block - try several fence patterns\nlet proof = text;\nconst m1 = text.match(/```lean\\s*\\n([\\s\\S]*?)```/);\nconst m2 = text.match(/```\\s*\\n([\\s\\S]*?)```/);\nif (m1) {\n  proof = m1[1];\n} else if (m2) {\n  proof = m2[1];\n} else {\n  proof = text.replace(/^```[^\\n]*\\n?/gm, '').replace(/```$/gm, '');\n}\nproof = proof.trim();\n\n// Split into import lines and theorem code\nconst lines = proof.split('\\n');\nconst imports = [];\nconst rest = [];\nlet pastImports = false;\nfor (const line of lines) {\n  if (!pastImports && (line.startsWith('import ') || line.trim() === '')) {\n    imports.push(line);\n  } else {\n    pastImports = true;\n    rest.push(line);\n  }\n}\nconst importCmd = imports.join('\\n').trim();\nconst theoremCmd = rest.join('\\n').trim();\n\nreturn [{ json: { proof, importCmd, theoremCmd, meetingJson } }];"
      },
      "id": "extract-proof",
      "name": "Extract Proof",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2160,
        32
      ]
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst { proof, meetingJson } = $input.first().json;\nconst res = await axios.post('http://python-mcp:7010/lean/command', { cmd: proof }, { timeout: 300000 });\nreturn [{ json: { ...res.data, meetingJson } }];"
      },
      "id": "verify-proof",
      "name": "Verify Proof",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        32
      ]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst meetingJson = response.meetingJson;\n\n// Check both ok flag AND for error-severity messages in result\nconst messages = (response.result && response.result.messages) || [];\nconst errors = messages.filter(m => m.severity === 'error');\n\nif (response.ok === true && errors.length === 0) {\n  return [{ json: { output: meetingJson } }];\n} else {\n  const errorMsgs = errors.map(e => e.data).join('; ');\n  const error = errorMsgs || response.error || JSON.stringify(response.result);\n  return [{ json: { output: 'Proof verification failed: ' + error } }];\n}"
      },
      "id": "check-result",
      "name": "Check Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2640,
        32
      ]
    },
    {
      "parameters": {
        "jsCode": "return [{ json: { output: 'No valid meeting could be arranged based on the available data.' } }];"
      },
      "id": "no-meeting",
      "name": "No Meeting Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1888,
        304
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.prompt }}",
        "options": {
          "systemMessage": "You are a database query agent with access to a Neo4j graph database containing clinical trial data. The database has entities: Language, City, Clinic, ClinicalTrial, Human, and Role types, connected by relationships like IS_A, ROLE, LIVES, SPEAKS, ASSIGNED, IS_IN.\n\nUse get_neo4j_schema to inspect the database structure before querying, then use read_cypher to answer the user's question. Be concise and informative in your response.",
          "maxIterations": 10
        }
      },
      "id": "query-agent",
      "name": "Query Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        1072,
        576
      ]
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-5-20250929",
        "options": {
          "maxTokensToSample": 256
        }
      },
      "id": "router-llm",
      "name": "Router LLM",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [
        224,
        528
      ],
      "credentials": {
        "anthropicApi": {
          "id": "a58asT6g6X06bWnB",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-5-20250929",
        "options": {
          "maxTokensToSample": 1024
        }
      },
      "id": "meeting-llm",
      "name": "Meeting LLM",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [
        992,
        400
      ],
      "credentials": {
        "anthropicApi": {
          "id": "a58asT6g6X06bWnB",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Execute a read-only Cypher query against Neo4j.",
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "parametersHeaders": {
          "values": [
            {
              "name": "Authorization",
              "valueProvider": "fieldValue",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "valueProvider": "fieldValue",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"read-cypher\",\"arguments\":{\"query\":\"{query}\"}},\"id\":30}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "query",
              "description": "Cypher read query",
              "type": "string"
            }
          ]
        }
      },
      "id": "meeting-read-cypher",
      "name": "meeting_read_cypher",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [
        1120,
        400
      ]
    },
    {
      "parameters": {
        "toolDescription": "Get the schema of the Neo4j database, including node labels, relationship types, and property keys.",
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "parametersHeaders": {
          "values": [
            {
              "name": "Authorization",
              "valueProvider": "fieldValue",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "valueProvider": "fieldValue",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"get-schema\",\"arguments\":{}},\"id\":40}"
      },
      "id": "meeting-get-schema",
      "name": "meeting_get_schema",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [
        1264,
        400
      ]
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-5-20250929",
        "options": {
          "maxTokensToSample": 1024
        }
      },
      "id": "query-llm",
      "name": "Query LLM",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [
        992,
        720
      ],
      "credentials": {
        "anthropicApi": {
          "id": "a58asT6g6X06bWnB",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Execute a read-only Cypher query against Neo4j.",
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "parametersHeaders": {
          "values": [
            {
              "name": "Authorization",
              "valueProvider": "fieldValue",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "valueProvider": "fieldValue",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"read-cypher\",\"arguments\":{\"query\":\"{query}\"}},\"id\":31}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "query",
              "description": "Cypher read query",
              "type": "string"
            }
          ]
        }
      },
      "id": "query-read-cypher",
      "name": "query_read_cypher",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [
        1120,
        720
      ]
    },
    {
      "parameters": {
        "toolDescription": "Get the schema of the Neo4j database, including node labels, relationship types, and property keys.",
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "parametersHeaders": {
          "values": [
            {
              "name": "Authorization",
              "valueProvider": "fieldValue",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "valueProvider": "fieldValue",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"get-schema\",\"arguments\":{}},\"id\":41}"
      },
      "id": "query-get-schema",
      "name": "query_get_schema",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [
        1264,
        720
      ]
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-5-20250929",
        "options": {
          "maxTokensToSample": 2048
        }
      },
      "id": "proof-llm",
      "name": "Proof LLM",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [
        1792,
        272
      ],
      "credentials": {
        "anthropicApi": {
          "id": "a58asT6g6X06bWnB",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Run a Lean 4 command. Send full theorem code including imports. Returns JSON with ok/error fields.",
        "method": "POST",
        "url": "http://python-mcp:7010/lean/command/form",
        "sendBody": true,
        "specifyBody": "keypair",
        "bodyParameters": {
          "parameters": [
            {
              "name": "cmd",
              "value": "{cmd}"
            }
          ]
        },
        "placeholderDefinitions": {
          "values": [
            {
              "name": "cmd",
              "description": "The complete Lean 4 code to check, including import statements and theorem definitions",
              "type": "string"
            }
          ]
        }
      },
      "id": "proof-lean-cmd",
      "name": "proof_lean_command",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [
        1920,
        272
      ]
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Neo4j MCP Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Neo4j MCP Init": {
      "main": [
        [
          {
            "node": "Delete All Nodes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete All Nodes": {
      "main": [
        [
          {
            "node": "Read Script",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Script": {
      "main": [
        [
          {
            "node": "Initialize DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize DB": {
      "main": [
        [
          {
            "node": "Warm Up Lean",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Trigger": {
      "main": [
        [
          {
            "node": "Router Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router Agent": {
      "main": [
        [
          {
            "node": "Parse Route",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Route": {
      "main": [
        [
          {
            "node": "IF Is Meeting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Is Meeting": {
      "main": [
        [
          {
            "node": "Meeting Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Query Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Meeting Agent": {
      "main": [
        [
          {
            "node": "Extract Meeting JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Meeting JSON": {
      "main": [
        [
          {
            "node": "IF Meeting Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Meeting Valid": {
      "main": [
        [
          {
            "node": "Proof Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Meeting Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Proof Agent": {
      "main": [
        [
          {
            "node": "Extract Proof",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Proof": {
      "main": [
        [
          {
            "node": "Verify Proof",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verify Proof": {
      "main": [
        [
          {
            "node": "Check Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Router Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Meeting LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Meeting Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "meeting_read_cypher": {
      "ai_tool": [
        [
          {
            "node": "Meeting Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "meeting_get_schema": {
      "ai_tool": [
        [
          {
            "node": "Meeting Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Query LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Query Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "query_read_cypher": {
      "ai_tool": [
        [
          {
            "node": "Query Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "query_get_schema": {
      "ai_tool": [
        [
          {
            "node": "Query Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Proof LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Proof Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "proof_lean_command": {
      "ai_tool": [
        [
          {
            "node": "Proof Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {},
  "versionId": "d7eb34b9-41fe-4426-931b-ee1e678fca5b",
  "activeVersionId": null,
  "versionCounter": 8,
  "triggerCount": 0,
  "tags": [],
  "shared": [
    {
      "updatedAt": "2026-02-16T11:51:37.949Z",
      "createdAt": "2026-02-16T11:51:37.949Z",
      "role": "workflow:owner",
      "workflowId": "testLeanMultiAgent01",
      "projectId": "2cqMQojVPN75JkWY",
      "project": {
        "updatedAt": "2026-02-11T17:09:13.264Z",
        "createdAt": "2026-02-11T17:04:37.196Z",
        "id": "2cqMQojVPN75JkWY",
        "name": "Matthew Fuchs <mattdfuchs@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "fac6b457-8dd2-4e95-8f65-c43abb581cd3"
      }
    }
  ]
}