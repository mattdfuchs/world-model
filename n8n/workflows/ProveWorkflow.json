{
  "updatedAt": "2026-02-16T11:51:37.947Z",
  "createdAt": "2026-02-16T11:51:37.947Z",
  "id": "testLeanMultiAgent01",
  "name": "Test Lean",
  "description": null,
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {},
      "id": "manual-trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        0,
        -200
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"initialize\",\n  \"params\": {\n    \"protocolVersion\": \"2024-11-05\",\n    \"capabilities\": {},\n    \"clientInfo\": {\n      \"name\": \"n8n-test\",\n      \"version\": \"0.1.0\"\n    }\n  },\n  \"id\": 1\n}",
        "options": {}
      },
      "id": "neo4j-init",
      "name": "Neo4j MCP Init",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        272,
        -200
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"write-cypher\",\"arguments\":{\"query\":\"MATCH (n) DETACH DELETE n\"}},\"id\":2}",
        "options": {}
      },
      "id": "delete-all-nodes",
      "name": "Delete All Nodes",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        528,
        -200
      ]
    },
    {
      "parameters": {
        "jsCode": "const fs = require('fs');\nconst cypher = fs.readFileSync('/home/node/.n8n-files/script.txt', 'utf8').trim();\nconst body = JSON.stringify({jsonrpc:'2.0',method:'tools/call',params:{name:'write-cypher',arguments:{query:cypher}},id:3});\nreturn [{ json: { body: body } }];"
      },
      "id": "read-script",
      "name": "Read Script",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        784,
        -200
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {}
      },
      "id": "init-db",
      "name": "Initialize DB",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1040,
        -200
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://python-mcp:7010/lean/command",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"cmd\": \"import WorldModel.KB.Relations\"}",
        "options": {
          "timeout": 300000
        }
      },
      "id": "warm-up-lean",
      "name": "Warm Up Lean",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1296,
        -200
      ]
    },
    {
      "parameters": {},
      "id": "chat-trigger",
      "name": "Chat Trigger",
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.1,
      "position": [
        0,
        300
      ],
      "webhookId": "chat-trigger-webhook"
    },
    {
      "parameters": {
        "options": {
          "systemMessage": "You are a request classifier. Analyze the user's input and determine if it is:\n1. A \"query\" \u2014 asking for information about the database (counts, lists, lookups, etc.)\n2. A \"meeting\" \u2014 requesting to arrange or schedule a meeting for a patient\n\nRespond with ONLY a JSON object, no other text:\n{\"type\": \"query\", \"prompt\": \"<original user input>\"}\nor\n{\"type\": \"meeting\", \"prompt\": \"<original user input>\"}",
          "maxIterations": 3
        }
      },
      "id": "router-agent",
      "name": "Router Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        300,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const raw = $input.first().json.output;\n// Strip markdown code fences if present\nconst text = raw.replace(/^```(?:json)?\\n?/gm, '').replace(/```$/gm, '').trim();\ntry {\n  const parsed = JSON.parse(text);\n  return [{ json: { type: parsed.type, prompt: parsed.prompt } }];\n} catch (e) {\n  // Fallback: if router output isn't valid JSON, treat as query\n  return [{ json: { type: \"query\", prompt: raw } }];\n}"
      },
      "id": "parse-route",
      "name": "Parse Route",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        560,
        300
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-meeting",
              "leftValue": "={{ $json.type }}",
              "rightValue": "meeting",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-meeting",
      "name": "IF Is Meeting",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        800,
        300
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.prompt }}",
        "options": {
          "systemMessage": "You are an automated scheduling agent. Your task is to arrange a meeting at a Clinic for a Patient with a Clinician. The Clinic must be in the same city the Patient lives in, the Clinician must be assigned to the Clinic, and they must have a language in common.\n\nUse get_neo4j_schema to inspect the database structure, then use read_cypher to find relevant data. Do not read the whole database \u2014 only what you need.\n\nIf there is no possible meeting, respond with ONLY: null\n\nIf a meeting is possible, respond with ONLY a JSON object (no other text):\n{\n  \"meeting\": {\"clinic\": \"<name>\", \"patient\": \"<name>\", \"clinician\": \"<name>\"},\n  \"facts\": [\n    {\"relation\": \"<predicate>\", \"source\": \"<entity>\", \"target\": \"<entity>\"},\n    ...\n  ],\n  \"explanation\": \"<why the facts support this meeting>\"\n}\n\nThe \"relation\" field must use the Lean4 predicate names: hasRole, speaks, lives, assigned, isIn.\nThe \"source\" and \"target\" must use the exact Lean4 constructor names (e.g., \"Jose\", \"ValClinic\", \"Spanish\", \"Valencia\", \"Clinician\", \"Patient\").\n\nDo not create the meeting in the database.",
          "maxIterations": 10
        }
      },
      "id": "meeting-agent",
      "name": "Meeting Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        1080,
        160
      ]
    },
    {
      "parameters": {
        "jsCode": "const text = $input.first().json.output;\ntry {\n  const trimmed = text.replace(/^```(?:json)?\\n?/gm, '').replace(/```$/gm, '').trim();\n  if (trimmed === 'null') {\n    return [{ json: { valid: false, meetingJson: null } }];\n  }\n  const match = trimmed.match(/\\{[\\s\\S]*\\}/);\n  if (match) {\n    const parsed = JSON.parse(match[0]);\n    const meetingJson = JSON.stringify(parsed);\n    const proofPrompt = 'Construct a Lean 4 proof of legalMeeting for this meeting specification:\\n' + meetingJson;\n    return [{ json: { valid: true, meetingJson, meetingData: parsed, proofPrompt } }];\n  }\n  return [{ json: { valid: false, meetingJson: null } }];\n} catch (e) {\n  return [{ json: { valid: false, meetingJson: null } }];\n}"
      },
      "id": "extract-json",
      "name": "Extract Meeting JSON",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1360,
        160
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-valid",
              "leftValue": "={{ $json.valid }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-valid",
      "name": "IF Meeting Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1600,
        160
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $input.first().json.proofPrompt }}",
        "options": {
          "systemMessage": "You are a Lean 4 proof agent. You receive a meeting specification in JSON and must construct a formal proof that the meeting is legal according to the WorldModel knowledge base.\n\n## Knowledge Base (WorldModel.KB.Relations)\n\nTypes:\n- Human: Jose | Rick | Allen | Matthew\n- Clinic: ValClinic | NiceClinic | ParisClinic | LondonClinic\n- City: Valencia | London | Nice | Paris\n- Language: English | Spanish | French\n- Role: Patient | Administrator | Clinician\n\nPredicate constructors:\n- hasRole: jose_patient, rick_admin, allen_clinician, matthew_clinician\n- speaks: jose_spanish, rick_english, allen_english, allen_spanish, matthew_english, matthew_french\n- lives: jose_valencia\n- assigned: rick_london, allen_val, matthew_nice\n- isIn: valClinic_valencia, niceClinic_nice, parisClinic_paris, londonClinic_london\n\n## Target: prove legalMeeting\n\nlegalMeeting(clinic, patient, clinician) requires:\n1. clinicInPatientCity: \u2203 city, isIn clinic city \u2227 lives patient city\n2. clinicianCanServe: hasRole clinician .Clinician \u2227 hasRole patient .Patient \u2227 \u2203 lang, speaks clinician lang \u2227 speaks patient lang\n3. assigned clinician clinic\n\n## Proof template\n\nimport WorldModel.KB.Relations\n\ntheorem meeting_legal : legalMeeting .<Clinic> .<Patient> .<Clinician> :=\n  \u27e8\u27e8.<City>, isIn.<clinic_city>, lives.<patient_city>\u27e9,\n   \u27e8hasRole.<clinician_role>, hasRole.<patient_role>, .<Language>, speaks.<clinician_lang>, speaks.<patient_lang>\u27e9,\n   assigned.<clinician_clinic>\u27e9\n\n## Example\n\nFor ValClinic, Jose, Allen:\n\nimport WorldModel.KB.Relations\n\ntheorem meeting_legal : legalMeeting .ValClinic .Jose .Allen :=\n  \u27e8\u27e8.Valencia, isIn.valClinic_valencia, lives.jose_valencia\u27e9,\n   \u27e8hasRole.allen_clinician, hasRole.jose_patient, .Spanish, speaks.allen_spanish, speaks.jose_spanish\u27e9,\n   assigned.allen_val\u27e9\n\n## Interpreting lean_command responses\n\nThe tool returns JSON with:\n- \"ok\": true means the code was accepted by Lean\n- \"messages\" with \"severity\": \"info\" are NORMAL informational output, NOT errors\n- \"messages\" with \"severity\": \"error\" are actual errors that need fixing\n- \"sorries\": [] (empty array) means no incomplete proofs \u2014 this is GOOD\n- An empty \"messages\" array or only \"info\" messages means SUCCESS\n\nA successful proof looks like: {\"ok\": true, \"result\": {\"messages\": [], \"sorries\": []}}\nThis means the proof compiled and is COMPLETE. Stop immediately and output the code.\n\n## Instructions\n\n1. Read the meeting JSON from the input\n2. Map entity names to Lean4 constructors using the predicate constructors listed above\n3. Construct the proof term following the template\n4. Use the lean_command tool to verify: send the COMPLETE code (with import WorldModel.KB.Relations)\n5. If the response has \"ok\": true and no \"error\" severity messages, the proof is VERIFIED \u2014 stop and output the result\n6. If there are errors, fix and retry\n7. When the proof compiles, output ONLY the complete Lean4 code in a ```lean code block",
          "maxIterations": 10
        }
      },
      "id": "proof-agent",
      "name": "Proof Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        1880,
        20
      ]
    },
    {
      "parameters": {
        "jsCode": "const text = $input.first().json.output;\nconst meetingJson = $('Extract Meeting JSON').first().json.meetingJson;\n\n// Extract lean code block - try several fence patterns\nlet proof = text;\nconst m1 = text.match(/```lean\\s*\\n([\\s\\S]*?)```/);\nconst m2 = text.match(/```\\s*\\n([\\s\\S]*?)```/);\nif (m1) {\n  proof = m1[1];\n} else if (m2) {\n  proof = m2[1];\n} else {\n  proof = text.replace(/^```[^\\n]*\\n?/gm, '').replace(/```$/gm, '');\n}\nproof = proof.trim();\n\n// Split into import lines and theorem code\nconst lines = proof.split('\\n');\nconst imports = [];\nconst rest = [];\nlet pastImports = false;\nfor (const line of lines) {\n  if (!pastImports && (line.startsWith('import ') || line.trim() === '')) {\n    imports.push(line);\n  } else {\n    pastImports = true;\n    rest.push(line);\n  }\n}\nconst importCmd = imports.join('\\n').trim();\nconst theoremCmd = rest.join('\\n').trim();\n\nreturn [{ json: { proof, importCmd, theoremCmd, meetingJson } }];"
      },
      "id": "extract-proof",
      "name": "Extract Proof",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2160,
        20
      ]
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst { proof, meetingJson } = $input.first().json;\nconst res = await axios.post('http://python-mcp:7010/lean/command', { cmd: proof }, { timeout: 300000 });\nreturn [{ json: { ...res.data, meetingJson } }];"
      },
      "id": "verify-proof",
      "name": "Verify Proof",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        20
      ]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst meetingJson = response.meetingJson;\n\n// Check both ok flag AND for error-severity messages in result\nconst messages = (response.result && response.result.messages) || [];\nconst errors = messages.filter(m => m.severity === 'error');\n\nif (response.ok === true && errors.length === 0) {\n  return [{ json: { output: meetingJson } }];\n} else {\n  const errorMsgs = errors.map(e => e.data).join('; ');\n  const error = errorMsgs || response.error || JSON.stringify(response.result);\n  return [{ json: { output: 'Proof verification failed: ' + error } }];\n}"
      },
      "id": "check-result",
      "name": "Check Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2640,
        20
      ]
    },
    {
      "parameters": {
        "jsCode": "return [{ json: { output: 'No valid meeting could be arranged based on the available data.' } }];"
      },
      "id": "no-meeting",
      "name": "No Meeting Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1880,
        300
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.prompt }}",
        "options": {
          "systemMessage": "You are a database query agent with access to a Neo4j graph database containing clinical trial data. The database has entities: Language, City, Clinic, ClinicalTrial, Human, and Role types, connected by relationships like IS_A, ROLE, LIVES, SPEAKS, ASSIGNED, IS_IN.\n\nUse get_neo4j_schema to inspect the database structure before querying, then use read_cypher to answer the user's question. Be concise and informative in your response.",
          "maxIterations": 10
        }
      },
      "id": "query-agent",
      "name": "Query Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        1080,
        500
      ]
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-5-20250929",
        "options": {
          "maxTokensToSample": 256
        }
      },
      "id": "router-llm",
      "name": "Router LLM",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [
        220,
        520
      ],
      "credentials": {
        "anthropicApi": {
          "id": "a58asT6g6X06bWnB",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-5-20250929",
        "options": {
          "maxTokensToSample": 1024
        }
      },
      "id": "meeting-llm",
      "name": "Meeting LLM",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [
        980,
        400
      ],
      "credentials": {
        "anthropicApi": {
          "id": "a58asT6g6X06bWnB",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Execute a read-only Cypher query against Neo4j.",
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "parametersHeaders": {
          "values": [
            {
              "name": "Authorization",
              "valueProvider": "fieldValue",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "valueProvider": "fieldValue",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"read-cypher\",\"arguments\":{\"query\":\"{query}\"}},\"id\":30}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "query",
              "description": "Cypher read query",
              "type": "string"
            }
          ]
        }
      },
      "id": "meeting-read-cypher",
      "name": "meeting_read_cypher",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [
        1120,
        400
      ]
    },
    {
      "parameters": {
        "toolDescription": "Get the schema of the Neo4j database, including node labels, relationship types, and property keys.",
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "parametersHeaders": {
          "values": [
            {
              "name": "Authorization",
              "valueProvider": "fieldValue",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "valueProvider": "fieldValue",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"get-schema\",\"arguments\":{}},\"id\":40}"
      },
      "id": "meeting-get-schema",
      "name": "meeting_get_schema",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [
        1260,
        400
      ]
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-5-20250929",
        "options": {
          "maxTokensToSample": 1024
        }
      },
      "id": "query-llm",
      "name": "Query LLM",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [
        980,
        720
      ],
      "credentials": {
        "anthropicApi": {
          "id": "a58asT6g6X06bWnB",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Execute a read-only Cypher query against Neo4j.",
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "parametersHeaders": {
          "values": [
            {
              "name": "Authorization",
              "valueProvider": "fieldValue",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "valueProvider": "fieldValue",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"read-cypher\",\"arguments\":{\"query\":\"{query}\"}},\"id\":31}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "query",
              "description": "Cypher read query",
              "type": "string"
            }
          ]
        }
      },
      "id": "query-read-cypher",
      "name": "query_read_cypher",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [
        1120,
        720
      ]
    },
    {
      "parameters": {
        "toolDescription": "Get the schema of the Neo4j database, including node labels, relationship types, and property keys.",
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "parametersHeaders": {
          "values": [
            {
              "name": "Authorization",
              "valueProvider": "fieldValue",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "valueProvider": "fieldValue",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"get-schema\",\"arguments\":{}},\"id\":41}"
      },
      "id": "query-get-schema",
      "name": "query_get_schema",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [
        1260,
        720
      ]
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-5-20250929",
        "options": {
          "maxTokensToSample": 2048
        }
      },
      "id": "proof-llm",
      "name": "Proof LLM",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [
        1780,
        260
      ],
      "credentials": {
        "anthropicApi": {
          "id": "a58asT6g6X06bWnB",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Run a Lean 4 command. Use #eval expr to evaluate expressions, or send full theorem code including imports.",
        "method": "POST",
        "url": "http://python-mcp:7010/lean/command",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"cmd\": \"{cmd}\"}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "cmd",
              "description": "Lean command to run, e.g. #eval 2 + 3 or a full theorem with imports",
              "type": "string"
            }
          ]
        },
        "timeout": 300000
      },
      "id": "proof-lean-cmd",
      "name": "proof_lean_command",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [
        1920,
        260
      ]
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Neo4j MCP Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Neo4j MCP Init": {
      "main": [
        [
          {
            "node": "Delete All Nodes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete All Nodes": {
      "main": [
        [
          {
            "node": "Read Script",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Script": {
      "main": [
        [
          {
            "node": "Initialize DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize DB": {
      "main": [
        [
          {
            "node": "Warm Up Lean",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Trigger": {
      "main": [
        [
          {
            "node": "Router Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router Agent": {
      "main": [
        [
          {
            "node": "Parse Route",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Route": {
      "main": [
        [
          {
            "node": "IF Is Meeting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Is Meeting": {
      "main": [
        [
          {
            "node": "Meeting Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Query Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Meeting Agent": {
      "main": [
        [
          {
            "node": "Extract Meeting JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Meeting JSON": {
      "main": [
        [
          {
            "node": "IF Meeting Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Meeting Valid": {
      "main": [
        [
          {
            "node": "Proof Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Meeting Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Proof Agent": {
      "main": [
        [
          {
            "node": "Extract Proof",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Proof": {
      "main": [
        [
          {
            "node": "Verify Proof",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verify Proof": {
      "main": [
        [
          {
            "node": "Check Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Router Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Meeting LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Meeting Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "meeting_read_cypher": {
      "ai_tool": [
        [
          {
            "node": "Meeting Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "meeting_get_schema": {
      "ai_tool": [
        [
          {
            "node": "Meeting Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Query LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Query Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "query_read_cypher": {
      "ai_tool": [
        [
          {
            "node": "Query Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "query_get_schema": {
      "ai_tool": [
        [
          {
            "node": "Query Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Proof LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Proof Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "proof_lean_command": {
      "ai_tool": [
        [
          {
            "node": "Proof Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": null,
  "versionId": "b2c3d4e5-0002-4000-9000-000000000002",
  "activeVersionId": null,
  "versionCounter": 6,
  "triggerCount": 0,
  "tags": [],
  "shared": [
    {
      "updatedAt": "2026-02-16T11:51:37.949Z",
      "createdAt": "2026-02-16T11:51:37.949Z",
      "role": "workflow:owner",
      "workflowId": "testLeanMultiAgent01",
      "projectId": "2cqMQojVPN75JkWY",
      "project": {
        "updatedAt": "2026-02-11T17:09:13.264Z",
        "createdAt": "2026-02-11T17:04:37.196Z",
        "id": "2cqMQojVPN75JkWY",
        "name": "Matthew Fuchs <mattdfuchs@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "fac6b457-8dd2-4e95-8f65-c43abb581cd3"
      }
    }
  ]
}
