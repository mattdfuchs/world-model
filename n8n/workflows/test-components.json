{
  "name": "Test Lean",
  "nodes": [
    {
      "parameters": {},
      "id": "manual-trigger",
      "name": "Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [0, -200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"initialize\",\n  \"params\": {\n    \"protocolVersion\": \"2024-11-05\",\n    \"capabilities\": {},\n    \"clientInfo\": {\n      \"name\": \"n8n-test\",\n      \"version\": \"0.1.0\"\n    }\n  },\n  \"id\": 1\n}",
        "options": {}
      },
      "id": "neo4j-init",
      "name": "Neo4j MCP Init",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [272, -200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"write-cypher\",\"arguments\":{\"query\":\"MATCH (n) DETACH DELETE n\"}},\"id\":2}",
        "options": {}
      },
      "id": "delete-all-nodes",
      "name": "Delete All Nodes",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [528, -200]
    },
    {
      "parameters": {
        "jsCode": "const fs = require('fs');\nconst cypher = fs.readFileSync('/home/node/.n8n-files/script.txt', 'utf8').trim();\nconst body = JSON.stringify({jsonrpc:'2.0',method:'tools/call',params:{name:'write-cypher',arguments:{query:cypher}},id:3});\nreturn [{ json: { body: body } }];"
      },
      "id": "read-script",
      "name": "Read Script",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [784, -200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {}
      },
      "id": "init-db",
      "name": "Initialize DB",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1040, -200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://python-mcp:7010/lean/command",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"cmd\": \"import WorldModel.KB.Relations\"}",
        "options": {
          "timeout": 300000
        }
      },
      "id": "warm-up-lean",
      "name": "Warm Up Lean",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1296, -200]
    },
    {
      "parameters": {},
      "id": "chat-trigger",
      "name": "Chat Trigger",
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.1,
      "position": [0, 300],
      "webhookId": "chat-trigger-webhook"
    },
    {
      "parameters": {
        "options": {
          "systemMessage": "You are a request classifier. Analyze the user's input and determine if it is:\n1. A \"query\" — asking for information about the database (counts, lists, lookups, etc.)\n2. A \"meeting\" — requesting to arrange or schedule a meeting for a patient\n\nRespond with ONLY a JSON object, no other text:\n{\"type\": \"query\", \"prompt\": \"<original user input>\"}\nor\n{\"type\": \"meeting\", \"prompt\": \"<original user input>\"}",
          "maxIterations": 3
        }
      },
      "id": "router-agent",
      "name": "Router Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [300, 300]
    },
    {
      "parameters": {
        "jsCode": "const raw = $input.first().json.output;\n// Strip markdown code fences if present\nconst text = raw.replace(/^```(?:json)?\\n?/gm, '').replace(/```$/gm, '').trim();\ntry {\n  const parsed = JSON.parse(text);\n  return [{ json: { type: parsed.type, prompt: parsed.prompt } }];\n} catch (e) {\n  // Fallback: if router output isn't valid JSON, treat as query\n  return [{ json: { type: \"query\", prompt: raw } }];\n}"
      },
      "id": "parse-route",
      "name": "Parse Route",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [560, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-meeting",
              "leftValue": "={{ $json.type }}",
              "rightValue": "meeting",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-meeting",
      "name": "IF Is Meeting",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [800, 300]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.prompt }}",
        "options": {
          "systemMessage": "You are an automated scheduling agent. Your task is to arrange a meeting at a Clinic for a Patient with a Clinician. The Clinic must be in the same city the Patient lives in, the Clinician must be assigned to the Clinic, and they must have a language in common.\n\nUse get_neo4j_schema to inspect the database structure, then use read_cypher to find relevant data. Do not read the whole database — only what you need.\n\nIf there is no possible meeting, respond with ONLY: null\n\nIf a meeting is possible, respond with ONLY a JSON object (no other text):\n{\n  \"meeting\": {\"clinic\": \"<name>\", \"patient\": \"<name>\", \"clinician\": \"<name>\"},\n  \"facts\": [\n    {\"relation\": \"<predicate>\", \"source\": \"<entity>\", \"target\": \"<entity>\"},\n    ...\n  ],\n  \"explanation\": \"<why the facts support this meeting>\"\n}\n\nThe \"relation\" field must use the Lean4 predicate names: hasRole, speaks, lives, assigned, isIn.\nThe \"source\" and \"target\" must use the exact Lean4 constructor names (e.g., \"Jose\", \"ValClinic\", \"Spanish\", \"Valencia\", \"Clinician\", \"Patient\").\n\nDo not create the meeting in the database.",
          "maxIterations": 10
        }
      },
      "id": "meeting-agent",
      "name": "Meeting Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [1080, 160]
    },
    {
      "parameters": {
        "jsCode": "const text = $input.first().json.output;\ntry {\n  const trimmed = text.replace(/^```(?:json)?\\n?/gm, '').replace(/```$/gm, '').trim();\n  if (trimmed === 'null') {\n    return [{ json: { valid: false, meetingJson: null } }];\n  }\n  const match = trimmed.match(/\\{[\\s\\S]*\\}/);\n  if (match) {\n    const parsed = JSON.parse(match[0]);\n    const meetingJson = JSON.stringify(parsed);\n    const proofPrompt = 'Construct a Lean 4 proof of legalMeeting for this meeting specification:\\n' + meetingJson;\n    return [{ json: { valid: true, meetingJson, meetingData: parsed, proofPrompt } }];\n  }\n  return [{ json: { valid: false, meetingJson: null } }];\n} catch (e) {\n  return [{ json: { valid: false, meetingJson: null } }];\n}"
      },
      "id": "extract-json",
      "name": "Extract Meeting JSON",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1360, 160]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-valid",
              "leftValue": "={{ $json.valid }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-valid",
      "name": "IF Meeting Valid",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1600, 160]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $input.first().json.proofPrompt }}",
        "options": {
          "systemMessage": "You are a Lean 4 proof agent. You receive a meeting specification in JSON with facts, and must construct a formal proof that the meeting is legal.\n\nYou must ONLY import WorldModel.KB.Relations. Do NOT import Facts. Define all entities and ground facts inline in your code based on the JSON input.\n\n## Available types (from WorldModel.KB.Relations)\n\n- `Human : String → Type` with constructor `.mk`\n- `Clinic : String → Type` with constructor `.mk`\n- `City : String → Type` with constructor `.mk`\n- `Language : String → Type` with constructor `.mk`\n- `Role` with constructors `.Patient`, `.Administrator`, `.Clinician`\n\n## Available relations (from WorldModel.KB.Relations)\n\n- `hasRole (a : Human h) (r : Role) : Type` — `.mk` to construct\n- `speaks (a : Human h) (b : Language l) : Type` — `.mk` to construct\n- `lives (a : Human h) (b : City c) : Type` — `.mk` to construct\n- `assigned (a : Human h) (b : Clinic c) : Type` — `.mk` to construct\n- `isIn (a : Clinic c) (b : City t) : Type` — `.mk` to construct\n\n## legalMeeting definition\n\n`legalMeeting clinic patient clinician` requires:\n1. `clinicInPatientCity`: ∃ city string and City value, Nonempty (isIn clinic city) ∧ Nonempty (lives patient city)\n2. `clinicianCanServe`: Nonempty (hasRole clinician .Clinician) ∧ Nonempty (hasRole patient .Patient) ∧ canCommunicate clinician patient\n3. `Nonempty (assigned clinician clinic)`\n\nwhere `canCommunicate` = ∃ lang string and Language value, Nonempty (speaks p1 lang) ∧ Nonempty (speaks p2 lang)\n\n## How to define entities\n\nFor each entity in the JSON facts, create a def:\n```\ndef jose : Human \\\"Jose\\\" := .mk \\\"Jose\\\"\ndef valClinic : Clinic \\\"ValClinic\\\" := .mk \\\"ValClinic\\\"\ndef valencia : City \\\"Valencia\\\" := .mk \\\"Valencia\\\"\ndef spanish : Language \\\"Spanish\\\" := .mk \\\"Spanish\\\"\n```\n\nFor each ground fact, create a def with `.mk`:\n```\ndef allen_is_clinician : hasRole allen .Clinician := .mk\ndef jose_is_patient : hasRole jose .Patient := .mk\ndef allen_speaks_spanish : speaks allen spanish := .mk\ndef jose_speaks_spanish : speaks jose spanish := .mk\ndef jose_lives_valencia : lives jose valencia := .mk\ndef allen_assigned_val : assigned allen valClinic := .mk\ndef valClinic_in_valencia : isIn valClinic valencia := .mk\n```\n\n## Complete example\n\nGiven JSON:\n```json\n{\\\"meeting\\\": {\\\"clinic\\\": \\\"ValClinic\\\", \\\"patient\\\": \\\"Jose\\\", \\\"clinician\\\": \\\"Allen\\\"},\n \\\"facts\\\": [\n   {\\\"relation\\\": \\\"hasRole\\\", \\\"source\\\": \\\"Allen\\\", \\\"target\\\": \\\"Clinician\\\"},\n   {\\\"relation\\\": \\\"hasRole\\\", \\\"source\\\": \\\"Jose\\\", \\\"target\\\": \\\"Patient\\\"},\n   {\\\"relation\\\": \\\"speaks\\\", \\\"source\\\": \\\"Allen\\\", \\\"target\\\": \\\"Spanish\\\"},\n   {\\\"relation\\\": \\\"speaks\\\", \\\"source\\\": \\\"Jose\\\", \\\"target\\\": \\\"Spanish\\\"},\n   {\\\"relation\\\": \\\"lives\\\", \\\"source\\\": \\\"Jose\\\", \\\"target\\\": \\\"Valencia\\\"},\n   {\\\"relation\\\": \\\"assigned\\\", \\\"source\\\": \\\"Allen\\\", \\\"target\\\": \\\"ValClinic\\\"},\n   {\\\"relation\\\": \\\"isIn\\\", \\\"source\\\": \\\"ValClinic\\\", \\\"target\\\": \\\"Valencia\\\"}\n ]}\n```\n\nProduce:\n```lean\nimport WorldModel.KB.Relations\n\ndef jose : Human \\\"Jose\\\" := .mk \\\"Jose\\\"\ndef allen : Human \\\"Allen\\\" := .mk \\\"Allen\\\"\ndef valClinic : Clinic \\\"ValClinic\\\" := .mk \\\"ValClinic\\\"\ndef valencia : City \\\"Valencia\\\" := .mk \\\"Valencia\\\"\ndef spanish : Language \\\"Spanish\\\" := .mk \\\"Spanish\\\"\n\ndef allen_is_clinician : hasRole allen .Clinician := .mk\ndef jose_is_patient : hasRole jose .Patient := .mk\ndef allen_speaks_spanish : speaks allen spanish := .mk\ndef jose_speaks_spanish : speaks jose spanish := .mk\ndef jose_lives_valencia : lives jose valencia := .mk\ndef allen_assigned_val : assigned allen valClinic := .mk\ndef valClinic_in_valencia : isIn valClinic valencia := .mk\n\ntheorem meeting_legal : legalMeeting valClinic jose allen :=\n  ⟨⟨\\\"Valencia\\\", valencia, ⟨.mk⟩, ⟨.mk⟩⟩,\n   ⟨⟨.mk⟩, ⟨.mk⟩, \\\"Spanish\\\", spanish, ⟨.mk⟩, ⟨.mk⟩⟩,\n   ⟨.mk⟩⟩\n```\n\nIMPORTANT: In the proof term, use `⟨.mk⟩` (angle brackets around .mk) for Nonempty witnesses. The proof structure matches legalMeeting:\n- First tuple: clinicInPatientCity = ⟨string, city_val, ⟨isIn_proof⟩, ⟨lives_proof⟩⟩\n- Second tuple: clinicianCanServe = ⟨⟨hasRole_clinician⟩, ⟨hasRole_patient⟩, string, lang_val, ⟨speaks1⟩, ⟨speaks2⟩⟩\n- Third: ⟨assigned_proof⟩\n\n## Interpreting lean_command responses\n\n- \"ok\": true with no \"error\" severity messages = SUCCESS. Stop and output the code.\n- \"messages\" with \"severity\": \"info\" are normal, NOT errors.\n- \"sorries\": [] (empty) means no incomplete proofs — GOOD.\n- Only \"severity\": \"error\" messages are actual errors.\n\n## Instructions\n\n1. Read the meeting JSON\n2. Define all needed entities inline (Human, Clinic, City, Language values)\n3. Define all ground facts inline from the JSON facts array\n4. Write the theorem and proof term\n5. Send the COMPLETE code to lean_command (starting with `import WorldModel.KB.Relations`)\n6. If ok with no errors, output the final code in a ```lean block\n7. If errors, fix and retry",
          "maxIterations": 10
        }
      },
      "id": "proof-agent",
      "name": "Proof Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [1880, 20]
    },
    {
      "parameters": {
        "jsCode": "const text = $input.first().json.output;\nconst meetingJson = $('Extract Meeting JSON').first().json.meetingJson;\n\n// Extract lean code block - try several fence patterns\nlet proof = text;\nconst m1 = text.match(/```lean\\s*\\n([\\s\\S]*?)```/);\nconst m2 = text.match(/```\\s*\\n([\\s\\S]*?)```/);\nif (m1) {\n  proof = m1[1];\n} else if (m2) {\n  proof = m2[1];\n} else {\n  proof = text.replace(/^```[^\\n]*\\n?/gm, '').replace(/```$/gm, '');\n}\nproof = proof.trim();\n\n// Split into import lines and theorem code\nconst lines = proof.split('\\n');\nconst imports = [];\nconst rest = [];\nlet pastImports = false;\nfor (const line of lines) {\n  if (!pastImports && (line.startsWith('import ') || line.trim() === '')) {\n    imports.push(line);\n  } else {\n    pastImports = true;\n    rest.push(line);\n  }\n}\nconst importCmd = imports.join('\\n').trim();\nconst theoremCmd = rest.join('\\n').trim();\n\nreturn [{ json: { proof, importCmd, theoremCmd, meetingJson } }];"
      },
      "id": "extract-proof",
      "name": "Extract Proof",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2160, 20]
    },
    {
      "parameters": {
        "jsCode": "const axios = require('axios');\nconst { proof, meetingJson } = $input.first().json;\nconst res = await axios.post('http://python-mcp:7010/lean/command', { cmd: proof }, { timeout: 300000 });\nreturn [{ json: { ...res.data, meetingJson } }];"
      },
      "id": "verify-proof",
      "name": "Verify Proof",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2400, 20]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst meetingJson = response.meetingJson;\n\n// Check both ok flag AND for error-severity messages in result\nconst messages = (response.result && response.result.messages) || [];\nconst errors = messages.filter(m => m.severity === 'error');\n\nif (response.ok === true && errors.length === 0) {\n  return [{ json: { output: meetingJson } }];\n} else {\n  const errorMsgs = errors.map(e => e.data).join('; ');\n  const error = errorMsgs || response.error || JSON.stringify(response.result);\n  return [{ json: { output: 'Proof verification failed: ' + error } }];\n}"
      },
      "id": "check-result",
      "name": "Check Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, 20]
    },
    {
      "parameters": {
        "jsCode": "return [{ json: { output: 'No valid meeting could be arranged based on the available data.' } }];"
      },
      "id": "no-meeting",
      "name": "No Meeting Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1880, 300]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.prompt }}",
        "options": {
          "systemMessage": "You are a database query agent with access to a Neo4j graph database containing clinical trial data. The database has entities: Language, City, Clinic, ClinicalTrial, Human, and Role types, connected by relationships like IS_A, ROLE, LIVES, SPEAKS, ASSIGNED, IS_IN.\n\nUse get_neo4j_schema to inspect the database structure before querying, then use read_cypher to answer the user's question. Be concise and informative in your response.",
          "maxIterations": 10
        }
      },
      "id": "query-agent",
      "name": "Query Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [1080, 500]
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-5-20250929",
        "options": {
          "maxTokensToSample": 256
        }
      },
      "id": "router-llm",
      "name": "Router LLM",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [220, 520],
      "credentials": {
        "anthropicApi": {
          "id": "a58asT6g6X06bWnB",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-5-20250929",
        "options": {
          "maxTokensToSample": 1024
        }
      },
      "id": "meeting-llm",
      "name": "Meeting LLM",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [980, 400],
      "credentials": {
        "anthropicApi": {
          "id": "a58asT6g6X06bWnB",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Execute a read-only Cypher query against Neo4j.",
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "parametersHeaders": {
          "values": [
            {
              "name": "Authorization",
              "valueProvider": "fieldValue",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "valueProvider": "fieldValue",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"read-cypher\",\"arguments\":{\"query\":\"{query}\"}},\"id\":30}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "query",
              "description": "Cypher read query",
              "type": "string"
            }
          ]
        }
      },
      "id": "meeting-read-cypher",
      "name": "meeting_read_cypher",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [1120, 400]
    },
    {
      "parameters": {
        "toolDescription": "Get the schema of the Neo4j database, including node labels, relationship types, and property keys.",
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "parametersHeaders": {
          "values": [
            {
              "name": "Authorization",
              "valueProvider": "fieldValue",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "valueProvider": "fieldValue",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"get-schema\",\"arguments\":{}},\"id\":40}"
      },
      "id": "meeting-get-schema",
      "name": "meeting_get_schema",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [1260, 400]
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-5-20250929",
        "options": {
          "maxTokensToSample": 1024
        }
      },
      "id": "query-llm",
      "name": "Query LLM",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [980, 720],
      "credentials": {
        "anthropicApi": {
          "id": "a58asT6g6X06bWnB",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "toolDescription": "Execute a read-only Cypher query against Neo4j.",
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "parametersHeaders": {
          "values": [
            {
              "name": "Authorization",
              "valueProvider": "fieldValue",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "valueProvider": "fieldValue",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"read-cypher\",\"arguments\":{\"query\":\"{query}\"}},\"id\":31}",
        "placeholderDefinitions": {
          "values": [
            {
              "name": "query",
              "description": "Cypher read query",
              "type": "string"
            }
          ]
        }
      },
      "id": "query-read-cypher",
      "name": "query_read_cypher",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [1120, 720]
    },
    {
      "parameters": {
        "toolDescription": "Get the schema of the Neo4j database, including node labels, relationship types, and property keys.",
        "method": "POST",
        "url": "http://mcp-neo4j:7011/mcp",
        "sendHeaders": true,
        "parametersHeaders": {
          "values": [
            {
              "name": "Authorization",
              "valueProvider": "fieldValue",
              "value": "={{ $env.NEO4J_MCP_AUTH_HEADER }}"
            },
            {
              "name": "Content-Type",
              "valueProvider": "fieldValue",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\"jsonrpc\":\"2.0\",\"method\":\"tools/call\",\"params\":{\"name\":\"get-schema\",\"arguments\":{}},\"id\":41}"
      },
      "id": "query-get-schema",
      "name": "query_get_schema",
      "type": "@n8n/n8n-nodes-langchain.toolHttpRequest",
      "typeVersion": 1.1,
      "position": [1260, 720]
    },
    {
      "parameters": {
        "model": "claude-sonnet-4-5-20250929",
        "options": {
          "maxTokensToSample": 2048
        }
      },
      "id": "proof-llm",
      "name": "Proof LLM",
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.2,
      "position": [1780, 260],
      "credentials": {
        "anthropicApi": {
          "id": "a58asT6g6X06bWnB",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "name": "lean_command",
        "description": "Run Lean 4 code and check it with the kernel. Send the COMPLETE Lean 4 source code including all import lines and the theorem with its proof term. Returns JSON with ok and result fields. If ok is true and there are no error-severity messages, the proof compiled successfully.",
        "language": "javaScript",
        "jsCode": "const axios = require('axios');\nconst res = await axios.post('http://python-mcp:7010/lean/command', {cmd: query}, {timeout: 300000});\nreturn JSON.stringify(res.data);"
      },
      "id": "proof-lean-cmd",
      "name": "proof_lean_command",
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.1,
      "position": [1920, 260]
    }
  ],
  "connections": {
    "Manual Trigger": {
      "main": [
        [
          {
            "node": "Neo4j MCP Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Neo4j MCP Init": {
      "main": [
        [
          {
            "node": "Delete All Nodes",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete All Nodes": {
      "main": [
        [
          {
            "node": "Read Script",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Script": {
      "main": [
        [
          {
            "node": "Initialize DB",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize DB": {
      "main": [
        [
          {
            "node": "Warm Up Lean",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chat Trigger": {
      "main": [
        [
          {
            "node": "Router Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router Agent": {
      "main": [
        [
          {
            "node": "Parse Route",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Route": {
      "main": [
        [
          {
            "node": "IF Is Meeting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Is Meeting": {
      "main": [
        [
          {
            "node": "Meeting Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Query Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Meeting Agent": {
      "main": [
        [
          {
            "node": "Extract Meeting JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Meeting JSON": {
      "main": [
        [
          {
            "node": "IF Meeting Valid",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Meeting Valid": {
      "main": [
        [
          {
            "node": "Proof Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Meeting Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Proof Agent": {
      "main": [
        [
          {
            "node": "Extract Proof",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Proof": {
      "main": [
        [
          {
            "node": "Verify Proof",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verify Proof": {
      "main": [
        [
          {
            "node": "Check Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Router Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Meeting LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Meeting Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "meeting_read_cypher": {
      "ai_tool": [
        [
          {
            "node": "Meeting Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "meeting_get_schema": {
      "ai_tool": [
        [
          {
            "node": "Meeting Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Query LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Query Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "query_read_cypher": {
      "ai_tool": [
        [
          {
            "node": "Query Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "query_get_schema": {
      "ai_tool": [
        [
          {
            "node": "Query Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Proof LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Proof Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "proof_lean_command": {
      "ai_tool": [
        [
          {
            "node": "Proof Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "b2c3d4e5-0002-4000-9000-000000000002",
  "id": "testLeanMultiAgent01"
}
